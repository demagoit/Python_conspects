M2
У Python також існує коротший варіант тернарного оператора.

some_data = None
msg = some_data or "Не було повернено даних"

Оператори continue та break працюють тільки всередині одного циклу. В ситуації вкладених циклів немає способу вийти з усіх циклів одразу.

try:
    val = int(val)
except ValueError:
    print(f"val {val} is not a number")
else:
    print("This will be printed if try succees")
finally:
    print("This will be printed anyway")

############################
M3
Зарезервоване слово global використовується для того, щоб оголосити, що x – це глобальна змінна, а значить, коли ми присвоюємо значення імені x всередині функції, ця зміна відобразиться на значенні змінної x в основному блоку програми.

from FILE import FUNCTION - все одно імортує весь FILE а не лише FUNCTION - тобто як робити це справа смаку. Щоб не тягнути весь файл заради однієї функціі - треба розбивати великий файл на дрібніші і імпортувати лише той, де є потрібна функція з усіма її залежностями, бо через існування залежностей іншого шляху нема.

М3_тест4
В минулому прикладі ми розглянули, як отримати доступ до змінних у локальній та глобальній області видимості. Є ще один тип області видимості, який зветься "нелокальною" (nonlocal) областю видимості, яка є чимось середнім між першими двома. Нелокальні області видимості зустрічаються коли ви визначаєте функції усередині функцій (- тоді nonlocal дає доступ із вкладеної ункції до змінних батьківскої функції, але не вище.)

М3_тест7
Іноді потрібно визначити функцію, здатну приймати будь-яке число параметрів. Цього можна досягти за допомогою зірочок.

Коли ми оголошуємо параметр з зірочкою (наприклад *topics), всі позиційні аргументи, починаючи з цієї позиції до кінця, будуть зібрані в кортеж під ім'ям topics. 

def make_article(title, *topics):
    print(topics)

make_article("Title", "first", "second", "third")  # ('first', 'second', 'third')

Водночас, коли ми оголошуємо параметри з двома зірочками **comments, всі ключові аргументи, починаючи з цієї позиції та до кінця, будуть зібрані в словник під ім'ям comments.

def make_article(title, **comments):
    print(comments)


make_article("Title", comment_one="first", comment_two="second", comment_third="third")
# {'comment_one': 'first', 'comment_two': 'second', 'comment_third': 'third'}

* та ** при оголошені функції [def make_article(title, **comments)] - це інструкція "запакувати всі аргументи..", а використання * та ** ри виклику функції [make_article(title, **comments)] - це буде інструкція "розпакувати" колекцію з ім'ям comments на перелік аргументів перед передачею їх у функцію make_article. * - розпаковує list, set, str натомість ** - розпаковує dict

М3_тест8

Іноді виникає необхідність, щоб деякі ключові параметри були доступні лише за ключем, а не як позиційні аргументи. Для цього їх треба оголосити після параметра з зірочкою. Наприклад

def modeling(factor, *numbers, correction):
    result = 0
    for number in numbers:
        result += number * factor
    result = result - correction
    return result


print(modeling(10, 1, 2, 3, correction=2))  # 58
Оголошення параметра correction після параметра зі зірочкою дає лише ключові аргументи. Якщо ми для аргументу не вкажемо значення за замовчуванням або не передамо його під час виклику, звернення до функції викликає помилку.

TypeError: modeling() missing 1 required keyword-only argument: 'correction'
Якщо нам потрібні аргументи, що передаються лише по ключу, але не потрібен параметр з зірочкою, то при оголошенні функції можна вказати просто зірочку з підкресленням, без вказування імені:

def modeling(factor, *_, correction):

М3
якщо імпорт з вкладеної папки не рацює - треба зайти в цю вкладену паку і виконати там touch __init__.py, який створить файл __init__.py в цій папці , що активує можливість імпорту фалів з цієй папки.
При запуску файлу з консолі, змінна __name__ = __main__. при імпорті файлу змінна __name__ буде як імя ри імпорті:
import test  => __name__ = test
import temp.test  => __name__ = temp.test
import temp.test as tt => __name__ = temp.test

М3_тест9

Python має особливість, яка називається рядками документації, скорочено docstrings. Це важливий інструмент, який допомагає краще документувати програму та полегшує її розуміння. Рядок у першому логічному рядку функції є рядком документації для цієї функції.

Рядки документації заведено записувати у формі багаторядкового рядка, де перший рядок починається з великої літери та закінчується точкою. Другий рядок залишається порожнім, а докладний опис починається з третього. Рекомендується слідувати такому формату для всіх рядків документації всіх нетривіальних функцій.

Доступ до рядка документації функції можна отримати за допомогою атрибуту функції __doc__. Зверніть увагу на подвійне підкреслення.

def fun(a, b=2, c=3):
    """Знаходить суму трьох параметрів.

     Перший параметр обов'язковий, два інших за замовчанням дорівнюють 2 і 3"""
    return a + b * c


print(fun.__doc__)

#########################
М4
при закінченні программи/скріпта - система видає exit code - якщо він 0 то все ОК, якщо помилка - зазвичай буде 1 (але є таблиця на різні випадки). На Лінуксі, щоб в терміналі побачити ексіт-код - треба після виконання скрипта написати команду $? (на вінді буде echo %ERRORLEVEL%). В Pithon є функція sys.exit(x) - де x буде задавати який ексіт-код видавати системі по завершенню скрипта.
бібліотека import_lib, дозволяє імпортувати модулі методом import_lib.import_module() по імені файлу, яки може бути задан змінною. Таким чином можна наробити файлів з різними назвами, але з однаковими назвами функций/змінних в середені (типу плагіни), і подгружати їх в основну програму за портеби, лишаючи основний код незмінним.

М4_тест10
Методи рядків

Для того, щоб перетворити перший символ кожного слова в рядку до верхнього регістру, треба використати метод title.

name = "avril lavigne"
print(name.title())  # Avril Lavigne
Щоб усі літери рядка перевести у верхній регістр, використовується метод upper:

name = "avril lavigne"
print(name.upper())  # AVRIL LAVIGNE
Для переведення в нижній регістр використовується метод lower:

name = "Avril Lavigne"
print(name.lower())  # avril lavigne
Щоб перевірити, що рядок починається з підрядка, є метод startswith:

name = "Avril Lavigne"
print(name.startswith('Av'))  # True
Щоб перевірити, що рядок закінчується підрядком, використовується метод endswith:

pic = "hello.jpg"
print(pic.endswith("jpg"))  # True
Щоб видалити пропуски біля правого краю рядка, використовують метод rstrip:

name = "Avril Lavigne        "
print(name.rstrip())  # Avril Lavigne
Щоб видалити пропуски біля лівого краю рядка, використовують метод lstrip:

name = "         Avril Lavigne"
print(name.lstrip())  # Avril Lavigne
Щоб видалити пропуски з обох боків рядка, використовують метод strip:

name = "         Avril Lavigne          "
print(name.strip())  # Avril Lavigne

службові символи типу '\n' '\t' хоч і позначаються 2 символами, но по-акту є 1 символом, тому їх видалення з кінця має бути [:-1] а не [:-2] 

М4_тест14
Отримати передані при запуску скрипту аргументи можна через список argv з пакета sys, де з'являються всі аргументи, з якими було запущено скрипт. Змінна sys.argv є списком рядків. Вона містить список аргументів командного рядка, тобто аргументів, переданих програмі із командного рядка.
Цікавою особливістю sys.argv є те, що першим елементом цього списку буде назва файлу скрипту test.py. Всі аргументи будуть в sys.argv у вигляді рядків у тому самому порядку, в якому вони були передані при виклику скрипту. Якщо ви очікуєте, що користувач повинен ввести число (ціле або дійсне), то вам потрібно перетворити рядок на потрібний вам тип самостійно. Python розділяє аргументи пробілами та в sys.argv пробіли не потрапляють.

M4 video 01/11/23 from 1:15:00 - importlib (~ make plagins)

################################
M5
    Але що робити, якщо нам потрібен текст із перенесенням рядків (коли в тексті більше одного рядка)? Для цього можна скористатися потрійним повторенням лапок:

    text = """This is first line
    And second line
    Last third line"""
    Коли інтерпретатор виявляє лапки, повторені тричі, він сприймає усі символи до наступних трьох закриваючих лапок, як символи рядка.

    Щоб структурувати код і не додавати зайвих перенесень, ви можете розбити одну рядкову змінну на декілька частин:

    one_line_text = "Textual data in Python is handled with str objects, or strings. "\
                    "Strings are immutable sequences of Unicode code points. "\
                    "String literals are written in a variety of ways: single quotes, double quotes, triple quoted."


    Зверніть увагу на символ \ в кінці першого та другого рядка коду, він вказує інтерпретатору ігнорувати закінчення рядка і продовжити відразу з наступного.

Детальне вивчення синтаксису регулярних виразів виходить за рамки цього курсу. Кому цікаво, можете продовжити знайомство з регулярними виразами за посиланням або детальніший опис з прикладами тут.

Ось гарна стаття на тему регулярних виразів, там багато прикладів і корисних посилань.

print(f"{datetime.date.now()!r}") — необов'язковий аргумент, вказується після символу ! і може бути або a для ascii(), r для repr() або s для str(). Це аналог запису print(repr(datetime.date.now()))
Відповідає за те, чи потрібно спробувати перетворити елемент, або відобразити елемент "як є". 

    як вирівняти положення елементу і чим (якими символами) доповнити
    print("|{:<10}|{:*^10}|{:>10}|".format('left', 'center', 'right'))  # |left      |**center**|     right|
    -- how to make 'proress bar' |###   | > |####  | -> https://stackoverflow.com/questions/3160699/python-progress-bar
або використовувати необов'язковий елемент у print('#', ""), який по замовченню '\n'

окрім модифікатора стринги f"" є ще b"" (byte) та r"" (row). r"" щоне буде використовуватися спец. символи і треба друкувати як є - тобто print(r"\\") => \\ а не як зазвичайprint("\\") => \

M5 video 08/11/23 from 1:30:00 - regex, globals()
у словник можна записати будь що, у тому числі функцію [без дужок () - бо буде виклик функції і запишеться не функція, а результат її роботи], і потім викликати функцію за назвою ключа, наприклад:
def func_1(a, b):
    ....
def func_2(a, b):
    ....
func_dict = {"add": func_1, "remove": func_2}
operaion = input("add or remove?")
result = func_dict[operation](a, b)

globals() - дає словник зі всіма змінними/функціями модуля. Це дає змогу робити попередні трюк (і не лише) без створення func_dict = {}
#################################################
M6 
video 13/11/23 0:44:00 fh.flush()
video 13/11/23 1:10:00 XOR cypher
os.sysem('cls') - виконання команд трміналу, нариклад 'cls'

#########################
M7
Для математичних обчислень у Python доданий пакет math
Якщо вам потрібна комплексна математика, то можна скористатися пакетом cmath
Використання кортежів у Python для передачі даних між обробниками — це хороша та поширена практика. Але є одна незручність у кортежів, вам необхідно пам'ятати індексацію елементів у кортежі і не плутати їх порядок. Це незручно і спеціально для таких випадків додали іменовані кортежі namedtuple
Часто вам потрібно підрахувати кількість елементів у певній послідовності і, щоб не писати одні й ті самі 6 рядків коду постійно, у collections додали спеціальний словник Counter
defaultdict Це спеціальний словник, який створює значення для ключів, яких в словнику не було за запитом. 
Щоб швидко додавати елементи на початок списку, в Python в пакеті collections є така колекція як deque

sq = [i ** 2 for i in range(1, 5+1)]- list()
sq = {i ** 2 for i in numbers} - set()
Для словників синтаксис comprehension трохи відрізняється, оскільки потрібно явно вказати ключ та значення:sq = {i: i ** 2 for i in numbers}

ПЕРЕДИВИТИСЯ
відео 20.11.23 - як пистати __init__.py, для чого __all__, для чого "." в import
для чого і як робити venv, як його активувати/деактивувати, requirements.txt, чому треба в gitignore pycash та venv 
відео 22.11.23 - 10:00 можна настроїти github на автоматичне тестування коу та автоматичне закидування пакетів на Pypi 
50:00 змінні оточення linux
54:00 PyCharm використовує PowerShell і команди для cmd, які записані в activate.bat не проходять
from .module import function - . для того, щоб айтон шукав module в той аці, де створюється файл а не в системних паках - де він його не знайде и дасть помилку
1:36:00 для завантаження пакетів на Pypi треба встановити twine
1:42:00 
pip install .
pip install -e .- збери і встанови пакет
python3 setup.py sdist - просто робить архів .tar в папці dist з дистрибутивом. після того виконуєм twine upload dist/* для завантаження на хмару Pypi
Віртуальні оточення для того, щоб не засмітчувати свою основну систему (особливо на линуксе, бо це може крашнути систему) і для того, щоб коли робиш pip freeze для створення файлу залежностй requirements.txt для проекту перед викладанням його дистрибутиву, надати лише ті залежності, які необхідняі для функціонування проекту, а не всі шо маєшь в основній системі.
Щоб додати у дистрибутив не .py файли, їх треба включити в файл MANIFEST.in а в setup.py додати параметр include_package_data=True
requirements.txt - залежності для проекту
setup.py install_requires=[] - залежності для пакету
#################################
M8
video 27/11/23 09:00 elasticsearch
.__dict__ - дає перелік існуючих параметрів функції
1:00:00 a = [x for x in range(10) if x%2 == 0] - if написано в кінці!!!
all(), any(), sum(), min(), max()
1:34:00 - підказки типу аргументу в def
1:44:00 - dict.setdefault() для створення ключа, якщо він не існує
1:51:00 - не використовувати в функціях дефолтні значення mutable типу [], {}...
2:10:00 pycodestyle.py pylint.py - скріпти на перевірку відповідності коду PEP8

ПЕРЕДИВИТИСЯ, КОД
video 29/11/23 0:40:00 flake8, pylint пакет контролю правил PIP8 в коді
0:51:00 tempfile.py - пакет для роботи з оперативкою в linux
0:65:00 |= для булевих це типу += для чисел
1:30:00 /= для об'екту path це типу +"\..." для вінди або +"/..." для линукса
1:46:00 - argparse.py
 
##################################
M9
Функція як об'єкт першого класу
Об'єктами першого класу (англ. first-class object, first-class entity, first-class citizen) у контексті конкретної мови програмування називаються елементи, які можуть бути передані як параметр, повернуті із функції, присвоєні змінній wiki.

Область видимості(LEGB) — це область у програмі (коді), в межах якої ви можете звернутися за ім'ям до вмісту змінної (або як ми вже з'ясували — функції).
У Python правила пошуку імен дуже прості:
спочатку пошук йде в локальному просторі імен (LOCAL);
якщо не знайдено в локальному, то в локальному на наступному рівні (ENCLOSED) і так далі, доки локальні не закінчаться;
далі буде перевірено глобальний (GLOBAL) простір імен (рівень модуля);
і в останню чергу простір вбудованих імен (BUILT INS) — це ключові слова і функції, що є частиною мови Python.
Це правило можна запам'ятати за його акронімом: (LOCAL, ENCLOSED, GLOBAL, BUILT INS).

Особливість існування вкладених локальних просторів імен і той факт, що вони створюються динамічно, дає можливість використати механізм замикань у Python.
def adder(val):
    def inner(x):
        return x + val
    return inner


two_adder = adder(2)
print(two_adder(3)) # 5
print(two_adder(5)) # 7

three_adder = adder(3)
print(three_adder(5))   # 8
print(three_adder(-3))  # 0

id(two_adder) == id(three_adder)    # False
В цьому прикладі ми створили функцію adder, яка повертає внутрішню функцію inner. Коли інтерпретатор заходить в adder (наприклад, у виразі two_adder = adder(2)) створюється новий локальний простір імен в adder, де створюється функція inner, яка і повертається з функції. Що не очевидно, так це те, що новостворена inner, коли її викликають, буде використовувати те значення val, яке було в adder на момент її створення.

Каррування — це перетворення функції від багатьох аргументів у набір функцій, кожна з яких є функцією від одного аргументу. Ми можемо передати частину аргументів у функцію і отримати назад функцію, що очікує інші аргументи.
def sum_func(x, y):
    return x + y


def sub_func(x, y):
    return x - y


OPERATIONS = {
    '-': sub_func,
    '+': sum_func
}


def get_handler(operator):
    return OPERATIONS[operator]


handler = get_handler('-')
handler(2, 3)           # -1

get_handler('+')(2, 3)  # 5

За такого підходу get_handler повертатиме нам потрібну функцію двох аргументів зі словника з функціями OPERATIONS. Це швидший і елегантніший спосіб уникнути величезних if ... elif ... конструкцій. Крім того, так ви можете зменшувати кількість аргументів, які передаєте у функцію до прийнятної кількості (не більше двох), створюючи "на льоту" нові функції, які вже "знають" про передані аргументи.

Є такий шаблон проектування — Декоратор. Цей шаблон полягає в тому, щоб розширювати існуючий функціонал, не вносячи змін в код цього самого функціоналу.
def logged_func(func):
    def inner(x, y):
        print(f'called with {x}, {y}')
        result = func(x, y)
        print(f'result: {result}')
        return result
    return inner


@logged_func
def complicated(x, y):
    return x / y
Тепер у коді явно видно, що complicated була задекорована logged_func у тому самому місці, де complicated була оголошена.

Генератор (ключове слово yield) — це не звичайна функція і, щоб отримати з нього значення, можна скористатися вбудованою функцією next.
Принципова відмінність генератора від ітератора в тому, що генератор обчислює наступне значення деякої послідовності у момент виклику, а ітератор перебирає збережену в пам'яті послідовність. З точки зору використання генератор та ітератор абсолютно ідентичні.
Синтаксис лямбда функцій:
-розпочинається з ключового слова lambda, після якого йде список позиційних аргументів функції через кому (аргументів може і не бути);
-потім йде двокрапка;
-далі йде тіло функції, суворо один вираз;
-результат виразу буде повернений як результат лямбди (return не потрібен).

map приймає на вхід функцію і послідовність, повертає генератор, який застосовує до кожного елементу послідовності функцію.
numbers = [1, 2, 3, 4, 5]
for i in map(lambda x: x ** 2, numbers):
    print(i)
Аналогічний map синтаксис у filter. filter теж приймає на вхід функцію та послідовність і повертає генератор. Головна відмінність у тому, що filter застосовує функцію до кожного елемента послідовності та повертає тільки елементи, які дають "truthy" результати.
for i in filter(lambda x: x % 2, range(1, 10+1)):
    print(i)
Reduce знаходиться в модулі functools у Python 3.0. Це складніша функція у порівнянні з map або filter. Вона приймає ітератор для обробки, але сама не є ітератором і повертає єдиний результат.

Функція reduce застосовує функцію з двома параметрами кумулятивно до елементів, що підлягають ітерації, необов'язково починаючи з початкового аргументу. Має наступний синтаксис:
reduce(func, iterable[, initial])

video 4.12.23 1:55:00 - git example with decorators
video 6.12.23 1:30:00 - decorator on decorator

###########################################
М10
Спосіб організації програм, коли об'єднують дані та функціонал усередині якогось об'єкта, називають об'єктноорієнтованою парадигмою програмування. Об'єктноорієнтоване програмування (ООП) по праву вважається однією з найефективніших методологій створення програмних продуктів. Ви пишете класи, що описують реально чинні предмети та ситуації, а потім створюєте об'єкти на основі цих описів.
ООП має чотири основні концепції, які відрізняють його від інших методологій програмування:
Абстракція
Інкапсуляція
Наслідування
Поліформізм
Абстракція - це модель якогось об'єкта або явища з реального світу, що відкидає незначні деталі, які не грають істотну роль в цьому контексті.
Інкапсуляція — це здатність об'єктів приховувати частину свого стану та поведінки від інших об'єктів, надаючи зовнішньому світу лише певний інтерфейс взаємодії із собою. За допомогою атрибутів класу ми виконуємо інкапсуляцію — приховуємо деталі реалізації під інтерфейсом класу.
Наслідування — це дуже потужний інструмент. Наслідуватися можна не тільки від одного класу, а можна одразу від кількох. Таким чином можна отримувати об'єкти, що поєднують у собі властивості багатьох класів.
є MRO (Method Resolution Order). MRO у Python працює наступним чином:

1.Шукає атрибут серед атрибутів самого класу. Саме завдяки цьому ви можете "перевизначати" батьківські атрибути.
2.Шукає атрибут у першого з батьків (той, що вказаний першим у списку батьків).
3.Шукає атрибут у наступного батька у списку батьків, доки такі є.
4.Шукає атрибут у батьках першого батька.
5.Повторює п.4 для всіх батьків.
6.Викликає виняток, що атрибут не знайдено.
Пошуки закінчуються, як тільки атрибут знайдено.

Часто для роботи потрібно створити об'єкти, які поводяться як стандартні контейнери Python, але з модифікованою поведінкою
Правильний спосіб отримати модифікований контейнер — це використовувати пакет collections та класи UserList, UserDict, UserString, які в ньому є.

У Python широко використовується механізм винятків (Exceptions) для того, щоб дати зрозуміти коду, що викликає, що саме пішло не так і що з цим робити. 
Ви можете створити власний виняток, який буде викликатися, якщо введення користувача не пройшло цю перевірку. 
class NameTooShortError(Exception):
    pass

while True:
    try:
        name = enter_name()
        break
    except NameTooShortError:
        print('Name is too short, need more than 3 symbols. Try again.')

Поліморфізм - це здатність програми вибирати різні реалізації при виклику операцій з однією і тією ж назвою.
Качина типізація — це механізм властивий Python, який дозволяє використовувати будь-які об'єкти один замість іншого, аби в обох були потрібні методи та поля. Інтерпретатор не перевіряє, що у функцію або метод був переданий об'єкт потрібного або дочірнього класу, достатньо щоб в об'єкта були потрібні методи і все буде працювати.
Сенс качиної типізації полягає в тому, щоб не дбати про точний клас об'єкта, а дбати про те, які методи для нього можна викликати та які операції над ним можна виконувати. Таким чином, треба просто передати об'єкт методу, знаючи, що при неправильному використанні буде викинуто виключення.
В цьому прикладі ми створили батьківський клас Mammal, у якого є метод voice та два дочірніх до нього Dog та Cat. Клас Record приймає на вхід методу record_animal об'єкт animalта викликає в нього метод voice, щоб вивести результати виконання voice у консоль. При цьому є клас Chupakabra, у якого також є метод voice, та хоч він і не наслідується від Mammal, але об'єкти цього класу так само можна передавати в record_animal. Головне, щоб атрибут називався так само і приймав ті самі аргументи (якщо це метод).

Класи — це структура мови програмування, яка дозволяє об'єднати в рамках однієї сутності змінні різних типів (поля) та функції (методи).
Наочною метафорою для класів і об'єктів може бути форма для випічки печива і печиво. Клас — це форма, яка задає суть об'єкта, які поля він містить і як можна оперувати з цими полями. А об'єкт класу — це печиво, воно обов'язково буде заданої класом форми, але начинка кожного печивка може бути різною.
Існує нестрога домовленість називати клас з великої літери і, якщо назва складається з декількох слів, то усі слова з великої літери без додаткових символів між ними.

Існує два типи полів: змінні класи та змінні об'єкта. Як видно з назви вони відрізняються тим, що належать або класу чи об'єкту відповідно.
Змінні класу – доступ до них мають усі екземпляри цього класу. Змінна класу існує тільки одна, та будь-який з об'єктів, коли змінює змінну класу, змінює її для решти екземплярів цього ж класу.
Змінні об'єкта - належать кожному окремому екземпляру класу. У цьому випадку кожен об'єкт має свою власну копію поля, тобто вона жодним чином не пов'язана з іншими такими ж полями в інших екземплярах.

Як бачимо — методи класу мають одну відмінність від звичайних функцій, вони повинні мати додатково ім'я self, яке додається до початку списку параметрів. 
метод __init__() — спеціальний метод конструктор, який автоматично виконується під час створення кожного нового екземпляра на базі класу Person.
Але що буде якщо нам необхідно для дочірнього класу Cat ввести нову властивість при створенні екземпляра, як порода breed?
cat = Cat("Simon", 10, 'british')
Для цього наш код має прийняти такий вигляд:
class Cat(Animal):
    def __init__(self, nickname, weight, breed):
        super().__init__(nickname, weight)
        self.breed = breed
        
    def say(self):
        return "Meow"

Метод __init__() отримує всю інформацію, що необхідна для створення екземпляра Cat. Функція super() спеціальна функція, яка допомагає Python пов'язати нащадка з батьком. Ця функція вказує Python явно викликати метод __init__() класу Animal, що є батьком Cat, внаслідок чого екземпляр Cat отримує всі атрибути класу батька. Ім'я super відповідає поширеній термінології: клас батько називається суперкласом, а клас нащадок - субкласом. Значить, Animal - це суперклас, а Cat - субклас.

Основна сила об'єктно-орієнтованого програмування полягає саме в можливості наслідування класів. Наслідування дає можливість створювати нові класи, що містять атрибути батьківських класів.
У цьому прикладі ми створили батьківський клас Human, який визначив, що у всіх є ім'я та метод voice.
Далі ми розширили функціонал класу Human та створили клас Developer, який наслідується від Human і додає йому поля field_description та language і метод make_some_code. І щоб реалізувати функціонал розробника конкретною мовою, ми зробили два класи PythonDeveloper та JSDeveloper. Тепер, якщо ми захочемо додати функціонал у всі дочірні для Human класи, то для цього можна додати потрібні атрибути в Human і вони автоматично з'являться і в PythonDeveloper, і JSDeveloper.

video 11.12.23 
35:00 - static method, static attribute
55:00 - наслідування, виключення методів батьків.
1:15:00 - патерни
1:45:00 - створення власних ексепшинов
1:50:00 - типи класів

video 13.12.23 
25:00 - class enum.Enum - розібратися
30:00 - в чому проблема зі створенням Engine в класі Player
1:03:00 - protected _attribut vs private __attribut
1:29:00 - __deinit__ - помилковий етод (не працює)
1:46:00 - __del__

############################################
M11
Методи, які відповідають за поведінку об'єктів, коли до них застосовуються синтаксичні конструкції Python, заведено називати "магічними".
 Вираз a + b "під капотом" перетворюється на a.__add__(b) і цей факт сам собою виглядає як "магія". Така поведінка — це частина мови Python і знати, які "магічні" методи за що відповідають — дуже важливо та обов'язково для розробника.
 Ці та подібні методи можна знайти в довідниках та підручниках з Python, але жодним чином із самої структури мови.
https://minhhh.github.io/posts/a-guide-to-pythons-magic-methods
Щодо цих методів є дві суворі домовленості: їх імена завжди складаються тільки з літер нижнього регістру та символів _, і починаються та закінчуються __ (двома символами нижнього підкреслення).
Метод, що найчастіше використовується, — це метод __init__. Цей метод відповідає за ініціалізацію об'єкта. 
Коли ви в інтерактивному режимі роботи з Python хочете побачити вміст деякого об'єкта, ви просто пишете його ім'я в консолі та інтерпретатор виводить рядком представлення цього об'єкта.За цей механізм внутрішнього читабельного представлення об'єктів відповідає магічний метод __repr__. Цей метод приймає лише один аргумент (self звичайно) і повинен повертати рядок.
Дуже схожий на нього метод, який відповідає за те, як об'єкт конвертується в рядок — це метод __str__. Коли ви викликаєте функцію str та передаєте їй якийсь об'єкт, то насправді цей об'єкт викликається методом __str__.
Квадратні дужки дозволяють вам звертатися до елементів послідовності за індексом або до елементів словника за ключем. Коли ви хочете отримати значення, використовуючи квадратні дужки, в об'єкта викликається метод __getitem__. Для запису значення з індексом або ключем викликається метод __setitem__. Обидва ці методи приймають першим аргументом self. __getitem__ другим аргументом приймає індекс або ключ, за яким потрібно знайти елемент, а __setitem__ другим аргументом приймає ключ/індекс, а третім значення, яке потрібно записати за цим ключем/індексом.
Функція у Python — це такий самий об'єкт, але у ньому реалізований метод __call__, який відповідає за синтаксис виклику з круглими дужками. 
Популярне завдання — це створення власних менеджерів контексту. У цьому нам допоможуть магічні методи, які відповідають за синтаксис with ... as ...:
__enter__ викликається, коли інтерпретатор заходить у контекст і те, що він поверне, буде записано в змінну після as;
__exit__ викликається, коли інтерпретатор виходить із блоку менеджера контексту. Буде викликаний в будь-якому випадку.
Метод __exit__ буде викликаний при виході з контексту помилково або штатно. __exit__ обов'язково повинен приймати аргументи exception_type, exception_value, traceback, окрім self. Метод __exit__ не дозволяє перехоплювати винятки, він потрібен лише для того, щоб правильно завершити контекст (закрити відкриті файли та з'єднання, повернути ресурси системі тощо).
Протокол ітератора у Python реалізований за допомогою методу __iter__. Цей метод повинен повертати ітератор. Ітератором може бути будь-який об'єкт, у якого є метод __next__, який за кожного виклику повертає значення. Щоб створити ітератор, достатньо реалізувати метод __next__.
У Python неможливо інкапсулювати (зробити недоступними) атрибути класу. Ви завжди можете отримати доступ до будь-якого атрибуту. Щоб якось вказати розробнику, що доступ до атрибуту безпосередньо небажаний, прийнято називати такі поля чи методи, починаючи з одного нижнього підкреслення. Якщо ж назвати атрибут так, що спочатку буде два нижні підкреслення, то включиться механізм "приховання" імен. Це не означає, що доступ до цього поля буде закрито, просто небагато ускладнений.
Як видно з цього прикладу, доступу за допомогою s.__real_secret ні, але можна отримати доступ до цього ж поля через s._Secret__real_secret, що загалом нічого не захищає.

Цей механізм можна використовувати для реалізації механізму setter та getter. Буває, виникає необхідність перевірити, що користувач хоче записати в поле. Для цього можна написати окремий метод, який буде перед збереженням значення в полі реалізовувати перевірку, але саме поле, як і раніше, залишиться доступним. Можна ж скористатися декоратором setter. Для обчислення значення "на льоту" або як пару для setter можна скористатися декоратором property, який перетворює будь-який метод на поле. 
У цьому прикладі поле __value можна вважати прихованим, воно певною мірою інкапсульовано. Однак значення в цьому полі може бути отримано і модифіковано безпосередньо. Ще декоратор property зручний, коли значення у полі треба обчислювати у момент звернення.
Усі математичні оператори можна перевизначити. Для цього є методи, відповідальні за кожний оператор:
__add__ додавання
__sub__ віднімання
__mul__ множення
__div__ ділення
__pow__ піднесення до степеня
та інші.
Операції порівняння, як і інші оператори, мають свої "магічні" методи:
__eq__(self, other) — визначає поведінку під час перевірки на відповідність (==).
__ne__(self, other) — визначає поведінку під час перевірки на невідповідність. !=.
__lt__(self, other) — визначає поведінку під час перевірки на менше <.
__gt__(self, other) — визначає поведінку під час перевірки на більше >.
__le__(self, other) — визначає поведінку під час перевірки на менше-дорівнює <=.
__ge__(self, other) — визначає поведінку під час перевірки на більше-дорівнює >=.
Якщо вам потрібно, щоб ваш об'єкт був порівнянний, ви можете реалізувати ці шість методів

video 18.12.23
00:10:00 - __new__, __init_subclass__, super().__new__(cls, iterable)
00:20:00 - singletone
00:28:00 - __str__ vs __repr__
01:00:00 - static variable. Присвоєння функції методу, який є зовнішньою функцією
01:20:00 - context manager, __ener__, __exiit__
01:39:00 - iterator
01:49:00 - чому iterator треба робити окремим класом - філосоія ООП
02:14:00 - Python не має реальної багатопоточності, є мультипроцесінг
video 20.12.23
1:00:00 - що таке "інтерфейс", як і для чого робиться
01:37:00 - чому iterator треба робити окремим класом - філосоія ООП, на співбесіді буде краще
01:52:00 - менеджер контексту
02:19:00 - двіжок гри на pygame
02:29:00 - різниця між інтерфеесом і абстрактним класом

##############################################
M12
Серіалізація (у програмуванні) — процес перетворення будь-якої структури даних у послідовність байтів. Зворотна до операції серіалізації є операція десеріалізації (структуризації) — відновлення початкового стану структури даних із бітової послідовності.
Найчастіше у Python використовуються три підходи до упакування та розпакування об'єктів:
- об'єкти, що мають рядкове представлення, приводяться до рядків і використовуються в такому вигляді (як ми зробили у прикладі вище);
- вбудований пакет pickle дозволяє працювати з вбудованими типами (словники, списки, кортежі, рядки, множини та ін.) і навіть з нескладними класами;
- протокол JSON підтримується Python і з невеликими обмеженнями дозволяє працювати з рядками, числами, списками, кортежами та словниками.

Python підтримує JSON і в стандартному постачанні є пакет json, в якому є все необхідне для роботи з JSON.
Варто бути обережним з конвертацією типів під час роботи з JSON у Python. Кортежі під час розпакування з JSON стають списками, ключі словника, якщо вони були числами, стають рядками ж.
dumps запаковує в byte-рядок об'єкт, loads розпаковує з byte-рядка в об'єкт. Ці методи потрібні, коли ми хочемо контролювати, що робити з byte представленням, наприклад, відправити його мережею або прийняти з мережі.
byte_string = json.dumps(some_data)
unpacked = json.loads(byte_string)
dump, load упаковує у відкритий для byte-запису файл та розпаковує із відкритого для byte-читання файлу.
with open(file_name, "w") as fh:
    json.dump(some_data, fh)
with open(file_name, "r") as fh:
    unpacked = json.load(fh)

Python підтримує роботу з табличними даними у форматі csv. Для цього у стандартному постачанні йде пакет csv.
Є два допоміжні класи в пакеті csv, які виконують роботу з табличними даними трохи зручніше:
Класи DictWriter та DictReader дозволяють працювати з рядками таблиці як зі словниками, де як ключі використовуються назви колонок (перший рядок).

Не всі об'єкти Python можна серіалізувати. Наприклад, не можна серіалізувати файловий дескриптор або системний ресурс. Але що робити, коли у вас є клас, об'єкт якого ви хочете запакувати, використовуючи pickle, але у нього є атрибути, що не серіалізуються? У такій ситуації ви можете скористатися магічними методами, які управляють серіалізацією та десеріалізацією за допомогою pickle.
Магічний метод __getstate__ викликається, коли pickle намагається отримати представлення об'єкта у вигляді byte-рядка. У звичайній реалізації __getstate__ повертає __dict__ словник, де зберігаються всі атрибути класу.
__setstate__(self, value)Цей магічний метод отримує на вхід словник, розпакований з файлу або byte-рядка. Поведінка за замовчуванням — це записати отримане значення в self.__dict__. Доопрацюймо клас Reader так, щоб він міг після розпакування продовжити читання з того самого місця.
    def __getstate__(self):
        attributes = {**self.__dict__}
        attributes['fh'] = None
        return attributes

    def __setstate__(self, value):
        self.__dict__ = value
        self.fh = open(value['file'])
        self.fh.seek(value['position'])

Python намагається заощаджувати пам'ять і не копіювати дані з однієї області пам'яті в іншу. Натомість інтерпретатор створює нове посилання (ще один псевдонім) на існуючий об'єкт, замість копіювання вмісту. Така поведінка може бути небажаною.
copy_list = my_list -> copy_list = my_list[:]
-> d = {1: 'a'}
d_copy = {**d}
Але з типами користувача так не зробиш. Щоб вирішити цю проблему, у Python є механізм копіювання — це функції із пакету copy.
Щоб створити "поверхневу" копію об'єкта, у пакеті copy є функція copy. Ця функція створює новий об'єкт такого самого типу і потім створює посилання на увесь вміст старого об'єкта в новий. Такий механізм досить хороший для роботи з об'єктами, де вже на першому рівні вкладеності немає змінних об'єктів, і він працює досить швидко.
Але для об'єктів із глибокою вкладеністю така функція все ж таки не дасть потрібного ефекту:
my_list = [1, 2, {1: 'a'}]
copy_list = copy.copy(my_list)
copy_list[2][2] = 'b'
print(my_list)    # [1, 2, {1: 'a', 2: 'b'}]
З цього прикладу видно, що хоча copy_list вже є новим об'єктом (не посилання на my_list), але вкладений у нього словник з індексом 2 — це один і той самий словник і в copy_list, і в my_list.
Для ситуацій, коли нам потрібно, щоб на будь-якому рівні вкладеності створювалися нові об'єкти, а не посилання на існуючі, у пакеті copy є функція deepcopy. Ця функція рекурсивно створює нові об'єкти.
Ще одна проблема вирішується за допомогою пакету copy — це копіювання об'єктів користувача. Щоб створити об'єкт, який буде коректно оброблятися функціями copy та deepcopy, ваш клас повинен реалізувати два магічних методи: __copy__ та __deepcopy__ для поверхневого та глибокого копіювання відповідно.
Словник memo зберігає як ключі id об'єктів і самі об'єкти як значення. Коли перевизначаємо як повинно відбуватися копіювання, ми можемо і не використовувати memo, якщо точно знаємо, що рекурсії не виникне.

video 26.12.23
0:06:00 - лайхак запису у .csv
0:30:00 - YAML як JSON, лише кортежі пакує з комнтами, які дають помилку при читанні щоб попредити
0:40:00 - PICKLE вбудований модуль, який може сереліазувати об'єкти, але при десеріалізації має бути об'явлено відповідний клас. Відтворювати клас в різних програмах - погана практика т.к. можна легко його змінити в одному місці і забути це зробити в іншому - тому краще його скрізь імпортувати з загального сховища
0:44:00 - PICKLE мое перезаписувати файл при читанні!!!
0:58:00 - __getstate__, __setstate__ - методи для контролю порядку серілізації/десеріалізації 
1:13:00 - чому не треба реалізовувати в __copy__ оведінку __deepcopy__ 
1:23:00 - параметр memo у __deepcopy__

video 26.12.23
0:00:00 - localhost, smlink, sys.argv[0] - лайхаки...
@classmethod - розібратися
0:50:00 - знайти і розібратися з лібою pydentic.py
1:00:00 - match...case...
1:05:00 - передивитися
1:20:00 - [i for i in range(10)]-list  (i for i in range(10))-genertor і кожне настуне занчення буде викликатися next(), щоб зробити tuple треба так tuple(i for i in range(10))
1:29:00 - __setstate__
1:37:00 - __getstate__
2:00:00 - byte-string на відміну від string - це те, що можна типу "виконати" за допомогою exec()
2:02:00 - як пересилати і виконати код через мережу за допомогою importlib
2:07:00 - pyserial - бібліотека для комунікації через  UART port з ембедед дівайсами


